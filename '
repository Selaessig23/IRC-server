#include <iomanip>  // For std::setw and std::setfill
#include <iostream>
#include <sstream>
#include "../Client/Client.hpp"
#include "../Server/Server.hpp"
#include "../includes/types.hpp"
#include "IrcCommands.hpp"

/**
 * @brief function to create reply-messages from server to client
 *
 * TODO
 * (1) add all required rpl messags according to rpl_code
 */
std::string IrcCommands::get_rpl(Server& base, enum RPL_MSG rpl) {
  std::string out;
  switch (rpl) {
    case RPL_WELCOME:
      return (" :Welcome to the " + base._network_name + " Network, " +
              "<nick>[!<user>@<host>]");
    case RPL_YOURHOST:
      return (" :Your host is " + base._server_name + " , running version " +
              base._version);
    case RPL_CREATED:
      return (" :This server was created " + base._created_at);
    default:
      return "";
  }
}

/**
 * @brief function to return the error message of errorcode
 *
 * TODO
 * (1) add all required error messages to corresponding error codes
 */
std::string IrcCommands::get_error(Server& base, enum PARSE_ERR err) {
  (void)base;
  std::string out;
  switch (err) {
    case EMPTY_CMD:
      return (" Command empty");
    case ERR_INPUTTOOLONG:
      return " :Input line was too long";
    case ERR_UNKNOWNCOMMAND:
      return (" <command> :Unknown command");
    case ERR_NOTREGISTERED:
      return (" :You have not registered");
    case ERR_NEEDMOREPARAMS:
      return " :<command> :Not enough parameters";
    case ERR_ALREADYREGISTERED:
      return " :You may not reregister";
    case ERR_PASSWDMISMATCH:
      return " :Password incorrect";
    default:
      return (out);
  }
}

/**
 * @brief function to sent out messages from server to client
 *
 * TODO
 * (1) set tag (only if clients support them, to check with CAP LS negotiation)
 */
void IrcCommands::send_message(Server& base, int numeric_msg_code, bool error,
                               Client& curr_client) {
  std::string out;
  std::stringstream ss;
  ss << std::setfill('0') << std::setw(2) << numeric_msg_code;

  out += ":";
  out += base._server_name;
  out += " " + ss.str();
  if (!curr_client.get_nick().empty())
    out = " <" + curr_client.get_nick() + ">";
  if (error == true)
    out += get_error(base, static_cast<PARSE_ERR>(numeric_msg_code));
  else
    out += get_rpl(base, static_cast<RPL_MSG>(numeric_msg_code));
  out += "\r\n";
  curr_client.add_client_out(out);
  curr_client.set_server_poll();
}

/**
 * @brief function to check if the client is already registered by 
 * server-access-password
 * it sends an error message to client in case if not
 * 451 ERR_NOTREGISTERED
 *
 * @return 1 in case of registered, 0 if not
 */
bool IrcCommands::client_register_check(Server& base, Client& to_check) {
  if (to_check.get_register_status() == 1)
    return (1);
  send_message(base, ERR_NOTREGISTERED, true, to_check);
  return (0);
}
