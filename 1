#include <algorithm>  //std::find
#include <iostream>
#include <list>
#include "../../Client/Client.hpp"
#include "../../Server/Server.hpp"
#include "../../includes/CONSTANTS.hpp"
#include "../../includes/types.hpp"
#include "../IrcCommands.hpp"

/**
 * @brief function to send private messages from server to client
 * FORMAT:
 * :<nick>!<user>@<host> PRIVMSG <target_nick> :<message>
 * OR
 * :<nick>!<user>@<host> PRIVMSG <channel_name> :<message>
 * (according to IRC protocol (RFC 1459 / 2812))
 */
static int send_privmsg(Client& sender, Client& receiver, std::string msg,
                        std::string channel) {
  std::string out;
  out += ":" + sender.get_nick();
  out += "!" + sender.get_user();
  out += "@" + sender.get_host();
  out += " PRIVMSG ";
  if (channel.empty())
    out += channel;
  else
    out += receiver.get_nick();
  out += " :" + msg;
  out += "\r\n";
  receiver.add_client_out(out);
  receiver.set_server_poll();
  return (0);
}

/**
 * @brief function to to send private messages between users, 
 * as well as to send messages to channels
 * IRC syyntax:
 * Command: PRIVMSG
 * Parameters: <target>{,<target>} <text to be sent>
 *
 * TODO
 * (1) check if NOTEXTTOSEND also gets sent if std is empty (current implementation)
 * (2) think about using Channel Membership Prefixes to address messages to certain group of people with a channel
 *     (founder and operator prefix are the only ones of interest)
 * (3) think about using wildcards for identifying users and channels (recipients)
 *
 * @return 0, in case of an error it returns error codes:
 *    ERR_NOSUCHNICK (401)
 *    ERR_CANNOTSENDTOCHAN (404)
 *    ERR_NORECIPIENT (411)
 *    ERR_NOTEXTTOSEND (412)
 *
 *
 * error codes from IRC-protocoll that are not considered in this implementation:
 *    ERR_NOSUCHSERVER (402) -> multy-server not implemented
 *    ERR_TOOMANYTARGETS (407) -> how to implement?
 *    ERR_NOTOPLEVEL (413) -> USE CASE?
 *    ERR_WILDTOPLEVEL (414) -> USE CASE?
 *    RPL_AWAY (301) -> AWAY-functionality not implemented
 */
int IrcCommands::privmsg(Server& base, const struct cmd_obj& cmd,
                         int fd_curr_client) {
  (void)fd_curr_client;
  if (cmd.parameters.empty()) {
    send_message(base, ERR_NORECIPIENT, true, NULL, *cmd.client);
    return (ERR_NORECIPIENT);
  }

  std::vector<std::string> recipients;
  std::vector<std::string>::const_iterator it_para = cmd.parameters.begin();
  for (; it_para != cmd.parameters.end() && *it_para->begin() == ',';
       it_para++) {
    recipients.push_back(*it_para);
  }

  if (it_para == cmd.parameters.end() && it_para->empty()) {
    send_message(base, ERR_NOTEXTTOSEND, true, NULL, *cmd.client);
    return (ERR_NOTEXTTOSEND);
  }

  std::string msg = *it_para;

  for (std::vector<std::string>::iterator it_rec = recipients.begin();
       it_rec != recipients.end(); it_rec++) {
    if (*it_rec->begin() == '#' || *it_rec->begin() == '&') {
      std::list<Channel>::iterator it_chan =
          std::find(base._channel_list.begin(), base._channel_list.end(), msg);
      //checks if Channel exists and if current client is member of channel (==allowed to send messages)
      if (it_chan != base._channel_list.end() &&
          std::find(it_chan->get_members_nicks().begin(),
                    it_chan->get_members_nicks().end(),
                    cmd.client->get_nick()) !=
              it_chan->get_members_nicks().end()) {
        //send message to each channel members
        std::list<Client*> chan_members = it_chan->get_members();
        for (std::list<Client*>::iterator it_chan_member = chan_members.begin();
             it_chan_member != it_chan->get_members().end(); it_chan_member++) {
          send_privmsg(*cmd.client, *(*it_chan_member), msg,
                       it_chan->get_name());
        }
      } else {
        //send error message
        send_message(base, ERR_CANNOTSENDTOCHAN, true, NULL, *cmd.client);
        return (ERR_CANNOTSENDTOCHAN);
      }
    } else {
      std::list<Client>::iterator it_nick =
          std::find(base._client_list.begin(), base._client_list.end(), msg);
      if (it_nick != base._client_list.end()) {
        //send message to client
        send_privmsg(*cmd.client, *it_nick, msg, "");
      } else {
        //send error message
        send_message(base, ERR_NOSUCHNICK, true, NULL, *cmd.client);
        return (ERR_NOSUCHNICK);
      }
    }
  }
  return (0);
}
