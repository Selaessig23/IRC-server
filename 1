#include "Server.hpp"
#include <netinet/in.h>  //for socket, bind, listen, accept
#include <poll.h>
#include <sys/socket.h>  //sockaddr_in
#include <unistd.h>      //for close()
#include <stdlib.h>
#include <fcntl.h>
#include <cstring>  //memset
#include <iostream>
#include <vector>
#include <stdexcept>  // to throw exceptions for runtime
#include "../CONSTANTS.hpp"
#include <poll.h>
#include <arpa/inet.h>   // for inet_ntoa()

Server::Server(int port, std::string& pw) {
  // TODO: validate Port num
  // On Unix/Linux, binding to ports <1024 usually requires root privileges.
  // Ports like 53 (DNS) or 123 (NTP) are either UDP or reserved
  // Ephemeral ports (49152â€“65535): These are meant for client-side connections,
  // not servers. 	Technically, you can bind a server here, but clients
  // might have trouble 	connecting due to firewall/NAT setups. Ports
  // that are already in use by another service will throw an error when trying
  // to bind to them
  _port = port;
  _fd_server = socket(AF_INET, SOCK_STREAM, 0);
  if (_fd_server < 0)
    throw std::runtime_error("Socket creation error.");
  // TODO: destroy socket on error and in destructor
  std::memset(&_addr, 0, sizeof(_addr));
  _addr.sin_family = AF_INET;
  _addr.sin_addr.s_addr = INADDR_ANY;
  _addr.sin_port = htons(port);
  // Assign socket to IP & Port
//   if (bind(_fd_server, reinterpret_cast<struct sockaddr*>(&_addr), sizeof(_addr)) < 0) {
  if (bind(_fd_server, (struct sockaddr*)&_addr, sizeof(_addr)) < 0) {
    close(_fd_server);
    throw std::runtime_error("Binding Error.");
  }
  // TODO:verify pw, if there are function specific rules
  _pw = pw;
}

Server::~Server() {};

int	Server::AddNewClient(int client_fd)
{
  struct pollfd ServerPoll;
  ServerPoll.events = POLLIN;
  ServerPoll.revents = 0;
  _poll_fds.push_back(ServerPoll);
  return (0);
}

int	Server::InitiatePoll()
{
  struct sockaddr_in client_addr; // would make sense to move this into a client class
  socklen_t client_len = sizeof(client_addr); // would make sense to move this into a client class
  const char *msg_welcome = "Hello from server!\n";
  const char *msg_waiting= "Please say something, server is waiting on response!\n";
  // int poll(struct pollfd *fds, nfds_t nfds, int timeout);
  // timeout = 0 for non-blocking
  // do we have to reserve memory for std::vector?
  poll(&_poll_fds[0], _poll_fds.size(), 0);
  while (1)
  {
	for (std::vector<struct pollfd>::iterator it = _poll_fds.begin(); it != _poll_fds.end(); it++) 
	{
	  if (_poll_fds[0].revents != 0)
	  {
		int client_fd = accept(_fd_server, (struct sockaddr*)&client_addr, &client_len); 
		// TODO: error-check if accept fails
		std:: cout << "New client connection from: " << inet_ntoa(client_addr.sin_addr) << std::endl;
		send(_poll_fds[0].fd, msg_welcome, strlen(msg_welcome), 0);
		AddNewClient(client_fd);
	  }
	  else if (it->revents != 0)
	  {
		char buf[1024];
		int recv_len = recv(it->fd, buf, sizeof(buf) - 1, 0); // waits until it receives any responce from client
		// TODO: error-check if recv_len fails
		buf[recv_len] = '\0';
		  std::cout << "Message from client fd: " << it->fd << " - " << buf << "length: " << recv_len << std::endl;
		  std::memset(buf, 0, 1024); // not necessary
		  recv_len = 0; // not necessary
	  }
  return (0);
}
  }
}

/**
 * @brief function to establish server loop
 * @return returns 1 in case of an error, otherwise 0
 */
int Server::init() {
  // set the socket to be non-blocking
  fcntl(_fd_server, F_SETFL, O_NONBLOCK);
  // This creates a passive socket like used in server applications
  fcntl(_fd_server, F_SETFL, O_NONBLOCK);
  if (listen(_fd_server, MAX_QUEUED) < 0) {
    close(_fd_server);
    std::cout << "Listen Error" << std::endl;
    return 1;
  }
  #ifdef DEBUG
    std::cout << "Server listening on port: " << _port << std::endl;
  #endif
  // attempt to establish a server loop that accepts several clients to connect
  // use the socket_fd to check for new connections with poll-function
  struct pollfd ServerPoll;
  ServerPoll.fd = _fd_server;
  ServerPoll.events = POLLIN;
  ServerPoll.revents = 0;
  _poll_fds.push_back(ServerPoll);
  // initiatePoll(); // sttempt to use poll
  std::vector<int> client_fd;
  const char *msg_welcome = "Hello from server!\n";
  const char *msg_waiting= "Please say something, server is waiting on response!\n";
  ssize_t recv_len = 0;
  char buf[1024];
  while (1)
  {
	  //std:: cout << "Waiting on new connections ..." << std::endl;
    int size = client_fd.size();
  	client_fd.push_back(accept(_fd_server, NULL, NULL)); // waits until connection was created
    // if (client_fd < 0)
   	// {
   	// 	std::cout << "Error: problems with accept" << std::endl;
   	// 	return (1); // return error or continue loop?
   	// }
	  // else if (client_fd > 0) // not necessary as accept waits until there is any connection
    // {
      send(client_fd[size - 1], msg_welcome, strlen(msg_welcome), 0);

      //std::cout << "Waiting on response from client" << std::endl;
      send(client_fd[size - 1], msg_waiting, strlen(msg_waiting), 0);
      for (std::vector<int>::iterator start = client_fd.begin(); start < client_fd.end(); start++){
        recv_len = recv(*start, buf, sizeof(buf) - 1, 0); // waits until it receives any responce from client
        buf[recv_len] = '\0';
        if (*start != -1) {
          std::cout << "Message from client fd: " << *start << " - " << buf << "length: " << recv_len << std::endl;
          std::memset(buf, 0, 1024);
          recv_len = 0;
          }
        }
    //}
	// TODO: add client_fd to vector of Client-class to manage connections to different clients
  }
  return 0;
}
